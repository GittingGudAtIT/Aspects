using Aspects.Attributes;
using Aspects.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Aspects
{
    [Generator]
    public class PropertyChangedGenerator : ISourceGenerator
    {
        private static readonly string s_notifyName = typeof(NotifyPropertyChangedAttribute).FullName;

        private sealed class FieldSyntaxReciever : ISyntaxContextReceiver
        {
            public Dictionary<string, IReadOnlyList<IFieldSymbol>> IdentifiedClasses { get; } 
                = new Dictionary<string, IReadOnlyList<IFieldSymbol>>(512);

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                if(context.Node is TypeDeclarationSyntax node && GetFields(context, node).Any())
                {
                    var fields = GetFields(context, node).ToArray();
                    var key = GetKey(node);

                    IdentifiedClasses[key] = fields;
                }
            }

            private static string GetKey(TypeDeclarationSyntax node)
            {
                var nodeText = node.GetText().ToString();

                int nameEnd;
                if (node.TypeParameterList is null)
                    nameEnd = nodeText.IndexOf(node.Identifier.Text) + node.Identifier.Text.Length;
                else
                    nameEnd = nodeText.IndexOf('>') + 1;

                return nodeText.Substring(0, nameEnd).Trim();
            }

            private static IEnumerable<IFieldSymbol> GetFields(GeneratorSyntaxContext context, TypeDeclarationSyntax node)
            {
                return node.ChildNodes()
                    .OfType<FieldDeclarationSyntax>()
                    .Where(fieldDec => fieldDec.AttributeLists.Any())
                    .SelectMany(fieldDec => fieldDec.Declaration.Variables.Select(v => context.SemanticModel.GetDeclaredSymbol(v) as IFieldSymbol))
                    .Where(field => field != null && field.GetAttributes().Any(fs => fs.AttributeClass.ToDisplayString() == s_notifyName));
                
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new FieldSyntaxReciever());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxContextReceiver is FieldSyntaxReciever propertyReciever)
            {
                foreach(var kp in propertyReciever.IdentifiedClasses)
                {
                    var typeInfo = kp.Value[0].ContainingType;

                    var src = GenerateClass(kp.Key, kp.Value);
                    context.AddSource($"{typeInfo.Name}_PropertyChanged.g.cs", SourceText.From(src, Encoding.UTF8));
                }
            }
        }

        private static string GenerateClass(string classDec, IReadOnlyList<IFieldSymbol> fields)
        {
            var type = fields[0].ContainingType;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using System.ComponentModel;");
            foreach (var dependency in Dependencies.TypeDeclarationDependencies(type))
                sb.AppendLine($"using {dependency};");
            sb.AppendLine();

            sb.AppendLine($"namespace {type.ContainingNamespace.ToDisplayString()}");
            sb.AppendLine("{");

            sb.Append('\t');
            sb.AppendLine(classDec);
            sb.AppendLine("\t{");

            if(!type.GetMembers().Any(sy => sy.Name == "PropertyChanged"))
            {
                sb.AppendLine("\t\tpublic event PropertyChangedEventHandler PropertyChanged;");
                sb.AppendLine();
            }

            sb.AppendLine(Property(fields[0]));
            for(int i = 1; i < fields.Count; i++)
            {
                sb.AppendLine();
                sb.AppendLine(Property(fields[i]));
            }

            sb.AppendLine("\t}");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string Property(IFieldSymbol field)
        {
            var name = PropertyName(field.Name);

            var sb = new StringBuilder("\t\tpublic ");
            sb.Append(field.Type.ToDisplayString());
            sb.Append(' ');
            sb.AppendLine(name);
            sb.AppendLine("\t\t{");
            sb.AppendLine($"\t\t\tget => {field.Name};");
            sb.AppendLine("\t\t\tset");
            sb.AppendLine("\t\t\t{");
            sb.AppendLine($"\t\t\t\t{field.Name} = value;");
            sb.AppendLine($"\t\t\t\tPropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof({name})));");
            sb.AppendLine("\t\t\t}");
            sb.Append("\t\t}");

            return sb.ToString();
        }

        private static string PropertyName(string fieldName)
        {
            while (fieldName.Length > 0 && fieldName[0] == '_')
                fieldName = fieldName.Substring(1);

            if (fieldName.Length > 0 && fieldName[0] >= 'a' && fieldName[0] <= 'z')
                fieldName = char.ToUpper(fieldName[0]) + fieldName.Substring(1);

            return fieldName;
        }
    }
}
