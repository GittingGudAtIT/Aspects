using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using TypeInfo = SourceInjection.SourceGeneration.Common.TypeInfo;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceInjection.SourceGeneration.Diagnostics;

namespace SourceInjection.SourceGeneration.Base
{
    internal abstract class TypeSourceGeneratorBase : IIncrementalGenerator
    {
        private readonly Dictionary<string, List<TypeInfo>> _allTypes = new Dictionary<string, List<TypeInfo>>(1024);

        protected internal abstract string Name { get; }

        protected abstract bool IsTargeted(INamedTypeSymbol symbol);

        protected abstract string TypeBody(TypeInfo typeInfo);

        protected virtual IEnumerable<string> Dependencies(TypeInfo typeInfo)
        {
            return Enumerable.Empty<string>();
        }

        protected virtual IEnumerable<string> InterfacesToAdd(TypeInfo typeInfo)
        {
            return Enumerable.Empty<string>();
        }

        protected IReadOnlyList<TypeInfo> GetTypes(string name)
        {
            if (_allTypes.TryGetValue(name, out var value))
                return value;
            return System.Array.Empty<TypeInfo>();
        }

        private void Consider(string name, TypeInfo type)
        {
            if (!_allTypes.TryGetValue(name, out var list))
                _allTypes.Add(name, new List<TypeInfo> { type });
            else if (!list.Contains(type))
                list.Add(type);
        }

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var collected = context.SyntaxProvider.CreateSyntaxProvider(
                (n, _) => n is TypeDeclarationSyntax, 
                (n, _) => new { Context = n, Symbol = (INamedTypeSymbol)n.SemanticModel.GetDeclaredSymbol(n.Node) })
                .Collect();

            context.RegisterSourceOutput(collected, (_, types) =>
            {
                foreach(var type in types)
                {
                    var typeInfo = new TypeInfo(type.Context, (TypeDeclarationSyntax)type.Context.Node, type.Symbol);
                    Consider(type.Symbol.ToDisplayString(), typeInfo);
                }
            });

            context.RegisterSourceOutput(collected, (sourceProductionContext, types) =>
            {
                foreach(var type in types.Where(t => IsTargeted(t.Symbol)))
                {
                    if (type.Context.Node.Parent is TypeDeclarationSyntax)
                        sourceProductionContext.ReportDiagnostic(Errors.NestedClassesAreNotSupported(type.Symbol, Name));
                    else
                    {
                        var typeInfo = new TypeInfo(type.Context, (TypeDeclarationSyntax)type.Context.Node, type.Symbol);

                        if (!typeInfo.HasPartialModifier)
                            sourceProductionContext.ReportDiagnostic(Errors.MissingPartialModifier(typeInfo.Symbol, Name));
                        else
                        {
                            var src = GeneratePartialType(typeInfo);
                            sourceProductionContext.AddSource(
                                $"{typeInfo.FullName.Replace('<', '[').Replace('>', ']').Replace('.', '/')}-{Name}.g.cs",
                                SourceText.From(src, Encoding.UTF8));
                        }
                    }
                }
            });
        }

        private string GeneratePartialType(TypeInfo typeInfo)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");

            foreach (var dependency in Dependencies(typeInfo))
                sb.AppendLine(dependency);

            sb.AppendLine();

            sb.AppendLine($"namespace {typeInfo.Symbol.ContainingNamespace.ToDisplayString()}");
            sb.AppendLine("{");
            sb.Append(Text.Indent());

            sb.Append(typeInfo.Declaration);
            var ifaces = InterfacesToAdd(typeInfo);
            if (!ifaces.Any())
                sb.AppendLine();
            else
                sb.AppendLine($" : {string.Join(", ", ifaces)}");
            sb.AppendLine(Text.Indent("{"));

            sb.AppendLine(TypeBody(typeInfo)
                .Replace("\n", $"\n{Text.Indent(tabCount: 2)}")
                .Insert(0, Text.Indent(tabCount: 2)));

            sb.AppendLine(Text.Indent("}"));
            sb.Append("}");

            return sb.ToString();
        }
    }
}
